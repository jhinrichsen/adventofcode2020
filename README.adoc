= Advent Of Code (AOC) 2020

My take on the AOC, documenting my errors.

Usually, i don't go for implementation speed, because that does not resonate well with me.

My second highest priority is runtime performance, and priority number one is
getting it right the first time.
Therefore, i always provide complete coverage via unit tests.
Go just makes this _so_ easy.

This document does not include solutions so no worries to read it at any point in time.
Solutions are hardcoded into unit tests, so you won't see any solutions as
long as you avoid looking at `*_test.go` files.

== Environment
- Go 1.15.6
- vim, vim-go, gopls, fed by a HHKB
- VisualStudio Code for debugging, fed by a MX Master 3
- Fedora 33
- AMD Ryzen 5 3400G on a Gigabyte B450

The package name is `aoc2020`.

Each day lives separately in a `day{{.n}}.go` and `day{{.n}}_test.go` file.
Unit test data, both examples and puzzle input, is in
`testdata/day{{.n}}.txt`, and `testdata/day{{.n}}_example.txt`.

== Day 1 
Warmup, nice and smooth.

Blattschuss, Blattschuss (answer correct on first try).

== Day 2 
Warmup, nice and smooth.

Blattschuss, Blattschuss.

== Day 3
The example's unit test succeeded, but part 1 failed, 284 being too low.
I refrained from implementing a too-complex implementation based on complex
numbers (x/y), and operated directly on the indexable lines[][] area.

Fail, Blattschuss.

== Day 4
First try 234 again too low.
Needed an extra blank line at the end of the file to make sure last pass was
validated.

For part 2, unit testing found an error before submitting the correct result.

Fail, Blattschuss.

`Hair color` is defined as `a # followed by exactly six characters 0-9 or a-f`.
So check for a leading '#', and then iterate the remaining slice:

====
----
if s[0] != '#' {
    return false
}
for i := range s[1:] {
    if '0' <= s[i] && s[i] <= '9' { // WRONG
        ...
    }
}
----
====

`s[1:]` is the correct slice, `i` is `0` for the first iteration, indexing
`s[i]` does _not_ index the slice but the original string, so it will point
to `#`.
====
----
num := s[1:]
for i := range num {
    if '0' <= num[i] && num[i] <= '9' { // CORRECT
        ...
    }
}
----
====

Benchmark for part 2:
====
----
go test -benchmem -run=^$ -bench ^(BenchmarkDay4Part2|BenchmarkDay4Part2IncludingInput)$

goos: linux
goarch: amd64
BenchmarkDay4Part2-8                 	    1064	   1220554 ns/op	  199106 B/op	    3504 allocs/op
BenchmarkDay4Part2IncludingInput-8   	     757	   1547982 ns/op	  281552 B/op	    4327 allocs/op
PASS
----
====

A seven digit ns/op is a two digit ms/op, so 12 resp. 15 ms/op.

== Day 5

Blattschuss, Blattschuss.

== Day 6

Blattschuss, Blattschuss.

== Day 7

Blattschuss

== Day 8

Blattschuss.

Part 2 ran like a champ, but the answer was not accepted, too low. After
re-reading the instructions, the program must terminate at the last line, not
somewhere.

== Day 9

Blattschuss, Blattschuss.

== Day 10

Blattschuss, Blattschuss.

I feel proud because i figured out the O(n) solution all by myself.

== Day 12

Bad first guess for part #1. Upon debugging, i realized `turn` commands come
with a number, so instead of `T` turning right, one needs to consider `T90`,
`T180` and the like.
The example contained a 'R90', but not multiple turns, so this one went
unnoticed.
Second try was correct.

Implementation is based on complex numbers (again), and Go's native support shows in 0 allocations:

====
----
BenchmarkDay12Part1-8   	  508400	      2472 ns/op	       0 B/op	       0 allocs/op
----
====

2 to 3 Î¼s for 774 commands, nice. Reading input not included.

== Day 13

Blattschuss.

====
----
BenchmarkDay13Part1-8                 	 4597266	       241 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay13Part1IncludingInput-8   	  123601	      8659 ns/op	    1080 B/op	       6 allocs/op
----
====

== Day 14

Blattschuss.

== Day 15

Blattschuss. Blattschuss.

Started implementation using arrays and indices, but soon ran out of control
with zero-based versus one-based and my beloved off-by-one. Restarted using a
map, runs like a charm.

No changes for part 2, benchmarks look ok:

====
----
BenchmarkDay15Part2/[0_3_6]-8         	       1	7025673926 ns/op	1723750824 B/op	13671118 allocs/op
BenchmarkDay15Part2/[1_3_2]-8         	       1	6637869463 ns/op	1725309776 B/op	13670596 allocs/op
BenchmarkDay15Part2/[2_1_3]-8         	       1	7122904051 ns/op	1725006832 B/op	13670445 allocs/op
BenchmarkDay15Part2/[1_2_3]-8         	       1	6876302588 ns/op	1724477424 B/op	13670918 allocs/op
BenchmarkDay15Part2/[2_3_1]-8         	       1	7039378239 ns/op	1723657952 B/op	13669432 allocs/op
BenchmarkDay15Part2/[3_2_1]-8         	       1	6679612463 ns/op	1724078544 B/op	13669214 allocs/op
BenchmarkDay15Part2/[3_1_2]-8         	       1	6478310634 ns/op	1724842464 B/op	13671933 allocs/op
----
====

That's about 6 to 7 seconds per sample.
I expect interesting solutions from the guys that really squeeze for performance.
Will be hard to come up with a O(1), i guess.

== Day 16

Blattschuss.

== Day 17

Blattschuss.

Nearly-bug #1: when figuring out the neighbours in 3D space, the number of neighbours
is fixed 26.
I created an array with appropriate capacity:

====
----
cubes := make([]cube, 3*3*3-1)
----
====

and then happily `append`ed
====
----
cubes = append(cubes, neighbour)
----
====

instead of writing directly to the array (`cubes[idx] = ...` ), creating 52
neighbours.
Not sure how to categorize this kind of error - muscle memory?

Nearly-bug #2: i started in optimized mode, in this puzzle z population grows
symmetrically in -z and +z. Considering only z >= 0, and mirroring -z somehow
into +z got me to 58 instead of 112 active cubes in the example. As soon as i
dropped this idea, it worked.

And yes, code became cleaner, and runtime performance, well...

====
----
BenchmarkDay17Part1-8   	      13	  95051825 ns/op	24855773 B/op	   38779 allocs/op
----
====

That's about 100 ms.
Fast enough for all practical purposes.


[quote, Donald Knuth]
Premature optimization is the root of all evil.

== Day 18

Blattschuss, Blattschuss.

Shunting Yard to the rescue, see doc/MR35.PDF.
Dijkstra, _1961_.

Part 2 needed just a slight reconfiguration of operator precedence, lucky me.

== Day 19

Blattschuss.

== Day 20

Blattschuss.

This one needed a bit of trial and error.
I keep vim open in an editing session terminal, and run continuous
`go test -run=Day20 -timeout=10s` in a second window.

The implemenation is pretty clumsy, but hey.

====
----
BenchmarkDay20Part1-8   	     307	   3722067 ns/op	  335614 B/op	    4964 allocs/op
----
====

3 ms, including loading puzzle input, finding corners, and validating expected
result.

